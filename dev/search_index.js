var documenterSearchIndex = {"docs":
[{"location":"combinatorial functions/#combinatorics","page":"Combinatorial Functions","title":"Combinatorial Functions","text":"","category":"section"},{"location":"combinatorial functions/","page":"Combinatorial Functions","title":"Combinatorial Functions","text":"stirlings2\nlogstirlings2\nstirlings2r\nlogstirlings2r\nunsignedstirlings1\nlogunsignedstirlings1\nbellnum\nbellnumr\nlogbellnumr\nPartitionSpace","category":"page"},{"location":"combinatorial functions/#EqualitySampler.stirlings2","page":"Combinatorial Functions","title":"EqualitySampler.stirlings2","text":"Compute the Stirlings numbers of the second kind. The EqualitySampler.ExplicitStrategy (default) uses an explicit loop and is computationally more efficient but subject to overflow, so using BigInt is advised. The EqualitySampler.RecursiveStrategy uses recursion and is mathematically elegant yet inefficient for large values.\n\n\n\n\n\n","category":"function"},{"location":"combinatorial functions/#EqualitySampler.logstirlings2","page":"Combinatorial Functions","title":"EqualitySampler.logstirlings2","text":"Compute the logarithm of the Stirlings numbers of the second kind with an explicit formula.\n\n\n\n\n\n","category":"function"},{"location":"combinatorial functions/#EqualitySampler.stirlings2r","page":"Combinatorial Functions","title":"EqualitySampler.stirlings2r","text":"stirlings2r(n::T, k::T, r::T) where T <: Integer\nstirlings2r(n::T, k::T, r::T, ::Type{EqualitySampler.ExplicitStrategy})  where T <: Integer\nstirlings2r(n::T, k::T, r::T, ::Type{EqualitySampler.RecursiveStrategy}) where T <: Integer\n\nCompute the r-Stirlings numbers of the second kind. The EqualitySampler.ExplicitStrategy (default) uses an explicit loop and is computationally more efficient but subject to overflow, so using BigInt is advised. The EqualitySampler.RecursiveStrategy uses recursion and is mathematically elegant yet inefficient for large values.\n\n\n\n\n\n","category":"function"},{"location":"combinatorial functions/#EqualitySampler.logstirlings2r","page":"Combinatorial Functions","title":"EqualitySampler.logstirlings2r","text":"logstirlings2r(n::T, k::T, r::T) where T <: Integer\n\nComputes the logarithm of the r-stirling numbers with an explicit formula.\n\n\n\n\n\n","category":"function"},{"location":"combinatorial functions/#EqualitySampler.unsignedstirlings1","page":"Combinatorial Functions","title":"EqualitySampler.unsignedstirlings1","text":"Compute the absolute value of the Stirlings numbers of the first kind. The EqualitySampler.ExplicitStrategy (default) uses an explicit loop and is computationally more efficient but subject to overflow, so using BigInt is advised. The EqualitySampler.RecursiveStrategy uses recursion and is mathematically elegant yet inefficient for large values.\n\n\n\n\n\n","category":"function"},{"location":"combinatorial functions/#EqualitySampler.logunsignedstirlings1","page":"Combinatorial Functions","title":"EqualitySampler.logunsignedstirlings1","text":"logunsignedstirlings1(n::Integer, k::Integer) -> Any\n\n\nCompute the logarithm of the absolute value of the Stirlings numbers of the first kind.\n\n\n\n\n\n","category":"function"},{"location":"combinatorial functions/#EqualitySampler.bellnum","page":"Combinatorial Functions","title":"EqualitySampler.bellnum","text":"Computes the Bell numbers.\n\n\n\n\n\n","category":"function"},{"location":"combinatorial functions/#EqualitySampler.bellnumr","page":"Combinatorial Functions","title":"EqualitySampler.bellnumr","text":"Computes the r-Bell numbers.\n\n\n\n\n\n","category":"function"},{"location":"combinatorial functions/#EqualitySampler.logbellnumr","page":"Combinatorial Functions","title":"EqualitySampler.logbellnumr","text":"logbellnumr(n::Integer, r::Integer) -> Any\n\n\nComputes the logarithm of the r-Bell numbers.\n\n\n\n\n\n","category":"function"},{"location":"combinatorial functions/#EqualitySampler.PartitionSpace","page":"Combinatorial Functions","title":"EqualitySampler.PartitionSpace","text":"struct PartitionSpace{T<:Integer, P<:EqualitySampler.AbstractPartitionSpace}\n\n# constructor\nPartitionSpace(k::T, ::Type{U} = EqualitySampler.DistinctPartitionSpace)\n\nA type to represent the space of partitions. EqualitySampler.AbstractPartitionSpace indicates whether partitions should contains duplicates or be distinct. For example, the distinct iterator will return [1, 1, 2] but not [2, 2, 1] and [1, 1, 3], which are returned when P = EqualitySampler.DuplicatedPartitionSpace.\n\n\n\n\n\n","category":"type"},{"location":"distributions over partitions/#Distributions-over-Partitions","page":"Distributions over Partitions","title":"Distributions over Partitions","text":"","category":"section"},{"location":"distributions over partitions/","page":"Distributions over Partitions","title":"Distributions over Partitions","text":"The following distributions are implemented.","category":"page"},{"location":"distributions over partitions/","page":"Distributions over Partitions","title":"Distributions over Partitions","text":"AbstractMvUrnDistribution\nUniformMvUrnDistribution\nBetaBinomialMvUrnDistribution\nCustomInclusionMvUrnDistribution\nRandomProcessMvUrnDistribution","category":"page"},{"location":"distributions over partitions/#EqualitySampler.CustomInclusionMvUrnDistribution","page":"Distributions over Partitions","title":"EqualitySampler.CustomInclusionMvUrnDistribution","text":"CustomInclusionMvUrnDistribution is similar to the BetaBinomialMvUrnDistribution in that the model probabilities are completely determined by the size of the partition. Whereas the BetaBinomialMvUrnDistribution uses a BetaBinomial distribution to obtain the probabilities, the CustomInclusionMvUrnDistribution can be used to specify any vector of probabilities. This distribution is particularly useful to sample uniformly from partitions of a given size. For example:\n\nrand(CustomInclusionMvUrnDistribution(4, ntuple(i->log(i==1), Val(4)))) # always all equal (1 parameter)\nrand(CustomInclusionMvUrnDistribution(4, ntuple(i->log(i==3), Val(4)))) # always 3 parameters\nrand(CustomInclusionMvUrnDistribution(4, ntuple(i->log(i==4), Val(4)))) # always completely distinct (4 parameters)\n\nThe function does not check if sum(exp, logpdf) â‰ˆ 1.0, that is the callers responsibility.\n\n\n\n\n\n","category":"type"},{"location":"distributions over partitions/","page":"Distributions over Partitions","title":"Distributions over Partitions","text":"Aside from the interface for multivariate distributions, the following methods are also defined.","category":"page"},{"location":"distributions over partitions/","page":"Distributions over Partitions","title":"Distributions over Partitions","text":"pdf_model,\nlogpdf_model\npdf_model_distinct\nlogpdf_model_distinct\npdf_incl\nlogpdf_incl","category":"page"},{"location":"#EqualitySampler","page":"EqualitySampler","title":"EqualitySampler","text":"","category":"section"},{"location":"","page":"EqualitySampler","title":"EqualitySampler","text":"EqualitySampler defines four distributions over partitions of a set:","category":"page"},{"location":"","page":"EqualitySampler","title":"EqualitySampler","text":"UniformMvUrnDistribution\nBetaBinomialMvUrnDistribution\nCustomInclusionMvUrnDistribution\nRandomProcessMvUrnDistribution","category":"page"},{"location":"","page":"EqualitySampler","title":"EqualitySampler","text":"Each of these is a subtype of the abstract type AbstractMvUrnDistribution which is a subtype of Distributions.DiscreteMultivariateDistribution.","category":"page"},{"location":"","page":"EqualitySampler","title":"EqualitySampler","text":"Thus, each of these types can be called with e.g., rand and logpdf.","category":"page"},{"location":"","page":"EqualitySampler","title":"EqualitySampler","text":"While a partition is usually defined without duplicates, the methods here do assume duplicates are present. For example, given 3 parameters (theta_1 theta_2 theta_3) there exist 5 unique partitions:","category":"page"},{"location":"","page":"EqualitySampler","title":"EqualitySampler","text":"partition constraints representation in Julia\ntheta_1 theta_2 theta_3 theta_1 = theta_2 = theta_3 [1, 1, 1]\ntheta_1 theta_2 theta_3 theta_1 = theta_2 neq theta_3 [1, 1, 2]\ntheta_1 theta_3 theta_2 theta_1 = theta_3 neq theta_3 [1, 2, 1]\ntheta_1 theta_2 theta_3 theta_1 neq theta_2 = theta_3 [1, 2, 2]\ntheta_1 theta_2 theta_3 theta_1 neq theta_2 neq theta_3 [1, 2, 3]","category":"page"},{"location":"","page":"EqualitySampler","title":"EqualitySampler","text":"However, we also consider [2, 2, 2] and [3, 3, 3] to be valid and identical to [1, 1, 1]. The main reason for this is that in a Gibbs sampling scheme, moving from [1, 2, 2] to [1, 1, 1] would be a natural transition, however, without duplicated partitions it would also be impossible. The default logpdf accounts for duplicated partitions, use logpdf_model_distinct to evaluate the logpdf without duplicated partitions.","category":"page"}]
}
